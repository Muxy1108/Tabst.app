#!/usr/bin/env node
/**
 * scripts/generate-alphatex-commands.js
 *
 * Generate a command / property data file from the upstream
 * `@coderline/alphatab-language-server`'s documentation export (if available).
 *
 * The script:
 *  - Loads `documentation` from `@coderline/alphatab-language-server` (if present).
 *  - Extracts `commands` (and basic `properties`) including:
 *      - name (no leading backslash)
 *      - label (with leading backslash for commands)
 *      - detail / shortDescription
 *      - documentation / longDescription
 *      - insertText (a snippet-like string if the doc includes parameters)
 *  - Falls back to a curated command list if source is missing some commands
 *  - Writes out a JSON file (default: `src/renderer/data/alphatex-commands-autogenerated.json`)
 *    or to a user-provided path via `--output`. The canonical file in the repository is
 *    `src/renderer/data/alphatex-commands.json` and can be used as a source of overrides.
 *
 * CLI usage:
 *  pnpm generate:commands
 *  pnpm generate:commands --merge  (merges existing file with generated)
 *  node scripts/generate-alphatex-commands.js --output path/to/file.json
 *  node scripts/generate-alphatex-commands.js --merge  (merges existing file with generated)
 *
 * Note:
 *  - The script is tolerant if the upstream package is not available; it falls back
 *    to a curated command list.
 *  - This helper is intended to generate/refresh machine-generated data; use `--merge`
 *    to preserve entries in your canonical `src/renderer/data/alphatex-commands.json`.
 */

import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";
import { createRequire } from "module";
const require = createRequire(import.meta.url);
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const args = process.argv.slice(2);
const outputArgIndex = args.indexOf("--output");
let outFile = path.resolve(
  __dirname,
  "..",
  "src",
  "renderer",
  "data",
  "alphatex-commands-autogenerated.json",
);
if (outputArgIndex !== -1 && args[outputArgIndex + 1]) {
  outFile = path.resolve(process.cwd(), args[outputArgIndex + 1]);
}
const mergeMode = args.includes("--merge");

// Attempt to load local commands JSON for overrides if present
let commandsJSON = null;
try {
  const localCommandsPath = path.resolve(
    __dirname,
    "..",
    "src",
    "renderer",
    "data",
    "alphatex-commands.json",
  );
  if (fs.existsSync(localCommandsPath)) {
    const raw = fs.readFileSync(localCommandsPath, "utf8");
    commandsJSON = JSON.parse(raw);
  }
} catch (err) {
  // ignore parse/read errors and leave commandsJSON as null
}

function safeEntries(obj) {
  if (obj == null) return [];
  if (obj instanceof Map) return Array.from(obj.entries());
  if (Array.isArray(obj)) return obj.map((v, i) => [i, v]);
  if (typeof obj === "object") return Object.entries(obj);
  return [];
}

function buildInsertTextFromCmd(cmd, cmdName) {
  // Try typical fields for parameters
  const params =
    (cmd &&
      (cmd.parameters ??
        cmd.args ??
        cmd.arguments ??
        (cmd.signatures &&
        Array.isArray(cmd.signatures) &&
        cmd.signatures.length > 0
          ? cmd.signatures[0].parameters
          : undefined))) ??
    [];
  const paramNames = Array.isArray(params)
    ? params.map((p) => {
        if (typeof p === "string") return p;
        return p?.name ?? p?.id ?? "arg";
      })
    : [];

  if (!paramNames.length) return "\\" + cmdName;
  // Use a snippet-like string with simple placeholders (frontend might not expand)
  return (
    "\\" +
    cmdName +
    " " +
    paramNames
      .map((n, idx) => {
        // Use ${1:arg} style that some snippet engines expect; the frontend can choose to
        // interpret this or insert as plain text.
        return `\${${idx + 1}:${n}}`;
      })
      .join(" ")
  );
}

function generateFromDocumentation(documentation) {
  const commands = [];
  const properties = [];

  // commands: many upstream packages expose commands as map/object or array.
  const cmdEntries = (documentation && documentation.commands) || {};

  for (const [key, cmd] of safeEntries(cmdEntries)) {
    // cmd may be a simple string or an object
    try {
      const cmdName =
        (cmd && (cmd.name ?? cmd.command ?? cmd.property ?? cmd.id)) ??
        String(key ?? "");
      if (!cmdName) continue;
      const shortDesc = cmd?.shortDescription ?? cmd?.description ?? "";
      const longDesc = cmd?.longDescription ?? cmd?.shortDescription ?? "";
      const insertText = buildInsertTextFromCmd(cmd, String(cmdName));
      commands.push({
        name: String(cmdName),
        label: String(cmdName),
        detail: String(shortDesc ?? ""),
        documentation: String(longDesc ?? ""),
        insertText,
      });
    } catch (err) {
      // ignore malformed items
    }
  }

  // properties (beatProperties, noteProperties, durationChangeProperties)
  const propGroups = [
    ["beatProperties", "beat property"],
    ["noteProperties", "note property"],
    ["durationChangeProperties", "duration property"],
  ];

  for (const [groupName, groupLabel] of propGroups) {
    const group = (documentation && documentation[groupName]) || {};
    for (const [key, prop] of safeEntries(group)) {
      try {
        const name = prop?.property ?? String(key ?? "");
        if (!name) continue;
        const shortDesc = prop?.shortDescription ?? prop?.description ?? "";
        const longDesc = prop?.longDescription ?? prop?.shortDescription ?? "";
        properties.push({
          name: String(name),
          label: String(name),
          detail: `${groupLabel}${shortDesc ? " â€¢ " + shortDesc : ""}`,
          documentation: String(longDesc ?? ""),
        });
      } catch (err) {
        // ignore malformed
      }
    }
  }

  return { commands, properties };
}

// A curated fallback command list (commonly used keys). This acts as a low friction
// catchall to ensure we don't miss frequent commands even if upstream docs are incomplete.
const curatedFallback = [
  "title",
  "subtitle",
  "artist",
  "composer",
  "arranger",
  "album",
  "copyright",
  "date",
  "tempo",
  "time",
  "meter",
  "key",
  "clef",
  "capo",
  "transpose",
  "ts",
  "track",
  "instrument",
  "program",
  "channel",
  "lyrics",
  "lyric",
  "repeat",
  "endrepeat",
  "measure",
  "bar",
  "note",
  "chord",
  "volume",
  "pan",
  "mute",
  "solo",
  "scoreinfo",
  "style",
  "author",
  "editor",
];

async function tryLoadDocumentation() {
  try {
    // Try synchronous CommonJS require first (works for CJS packages).
    try {
      const docModule = require("@coderline/alphatab-language-server");
      if (docModule) {
        // 'documentation' might be exported either as a top-level property or the default export
        const documentation =
          docModule.documentation ?? docModule.default?.documentation ?? null;
        return documentation;
      }
    } catch (requireErr) {
      // Fallback: try dynamic import (works for ESM packages)
      try {
        const imported = await import("@coderline/alphatab-language-server");
        const documentation =
          imported.documentation ?? imported.default?.documentation ?? null;
        return documentation;
      } catch (importErr) {
        // not installed or not available
        return null;
      }
    }
    return null;
  } catch (e) {
    // not installed or not available
    return null;
  }
}

function mergeUniqueByName(listA, listB) {
  // returns list containing unique items by `name` (case-insensitive)
  const map = new Map();
  const push = (it) => {
    if (!it || !it.name) return;
    const key = String(it.name).toLowerCase();
    if (!map.has(key)) map.set(key, it);
  };
  for (const a of listA) push(a);
  for (const b of listB) push(b);
  return Array.from(map.values());
}

function buildCommandData({ fromDocumentation, includeFallback = true }) {
  let commands = (fromDocumentation && fromDocumentation.commands) || [];
  let properties = (fromDocumentation && fromDocumentation.properties) || [];

  // If arrays, leave them as arrays. If it's an object/map, normalize via safeEntries
  if (!Array.isArray(commands) && typeof commands === "object") {
    commands = safeEntries(commands).map(([key, cmd]) => {
      const name = cmd?.name ?? cmd?.command ?? cmd?.property ?? key ?? key;
      const shortDesc = cmd?.shortDescription ?? cmd?.description ?? "";
      const longDesc = cmd?.longDescription ?? shortDesc ?? "";
      const insertText = buildInsertTextFromCmd(cmd, name);
      return {
        name,
        label: "\\" + name,
        detail: shortDesc,
        documentation: longDesc,
        insertText,
      };
    });
  }

  if (!Array.isArray(properties) && typeof properties === "object") {
    properties = safeEntries(properties).map(([key, prop]) => {
      const name = prop?.property ?? key;
      const shortDesc = prop?.shortDescription ?? prop?.description ?? "";
      const longDesc = prop?.longDescription ?? shortDesc ?? "";
      return {
        name,
        label: name,
        detail: shortDesc,
        documentation: longDesc,
      };
    });
  }

  // Add curated fallback commands (only if not present)
  const fallbackCommands = includeFallback
    ? curatedFallback.map((c) => ({
        name: c,
        label: `\\${c}`,
        detail: "",
        documentation: "",
        insertText: `\\${c}`,
      }))
    : [];

  const mergedCommands = mergeUniqueByName(commands, fallbackCommands);
  const mergedProperties = mergeUniqueByName(properties, []); // no fallback for properties

  return {
    commands: mergedCommands,
    properties: mergedProperties,
  };
}

/**
 * Main execution
 */
(async function run() {
  const doc = await tryLoadDocumentation();
  let data = null;

  if (doc) {
    // Convert doc into our data representation
    data = generateFromDocumentation(doc);
  } else {
    // If doc not available, start with empties and rely on curated fallback
    console.warn(
      "No upstream documentation found. Falling back to curated command list.",
    );
    data = {
      commands: [],
      properties: [],
    };
  }

  // Merge with local JSON if `commandsJSON` (local overrides) exists; local JSON takes precedence
  let finalData = null;
  try {
    if (commandsJSON && typeof commandsJSON === "object") {
      const mergedCommands = mergeUniqueByName(
        commandsJSON.commands || [],
        data.commands || [],
      );
      const mergedProperties = mergeUniqueByName(
        commandsJSON.properties || [],
        data.properties || [],
      );
      finalData = {
        commands: mergedCommands,
        properties: mergedProperties,
      };
    } else {
      finalData = buildCommandData({
        fromDocumentation: data,
        includeFallback: true,
      });
    }
  } catch (err) {
    finalData = buildCommandData({
      fromDocumentation: data,
      includeFallback: true,
    });
  }

  // If CLI invoked with --merge and an existing file is present, preserve its entries as highest priority
  if (mergeMode && fs.existsSync(outFile)) {
    try {
      const existing = JSON.parse(fs.readFileSync(outFile, "utf-8"));
      const mergedCommands = mergeUniqueByName(
        existing.commands || [],
        finalData.commands || [],
      );
      const mergedProperties = mergeUniqueByName(
        existing.properties || [],
        finalData.properties || [],
      );
      finalData = { commands: mergedCommands, properties: mergedProperties };
    } catch (e) {
      // ignore any parse error and continue
    }
  }

  // Ensure output directory exists
  const dir = path.dirname(outFile);
  fs.mkdirSync(dir, { recursive: true });

  // Pretty-print to JSON file for checking/manual edits
  fs.writeFileSync(outFile, JSON.stringify(finalData, null, 2), "utf8");
  console.log("Generated AlphaTex command data at:", outFile);
})();
