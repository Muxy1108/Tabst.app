# Print Preview Music Font Scaling Debug Log

**Date:** 2026-01-14
**Status:** Resolved
**Module:** PrintPreview.tsx / alphaTab

## CN 中文简要概括

这是一个非常经典且隐蔽的**“样式作用域失效”**问题。

这个修复之所以成功，是因为我们手动补回了 AlphaTab 在特定情况下依赖、但我们的代码未能正确传递的 **CSS 上下文**。

以下是深层原理解析：

### 1. AlphaTab 的“混合渲染策略”

AlphaTab 在渲染 SVG 时，对 **音乐符号（Glyphs）** 的大小控制采取了一种混合策略：

1.  **基准大小（Base Size）**：依靠 **CSS 类** 控制。
    AlphaTab 内部硬编码了一个常量 `Fc.MusicFontSize = 34px`。这是 Bravura 字体在标准五线谱高度下的基准大小。它通过注入类似这样的全局 CSS 规则来应用：

    ```css
    .at-surface.at1 .at {
      font-size: 34px;
    }
    ```

2.  **动态缩放（Scale）**：依靠 **内联样式（Inline Style）** 控制。
    如果在渲染时设置了缩放（例如 0.6），它会计算 `34px * 0.6` 或者直接在元素上写 `font-size: 60%`（相对于父级）。

### 2. 为什么之前会失败？（“优化”引发的 Bug）

AlphaTab 的渲染器里有一段“聪明”的优化逻辑：

```javascript
// 如果计算出的缩放比例 n 恰好等于 1
this.buffer +=
  1 !== n
    ? ` style="font-size: ${100 * n}%; stroke:none"`
    : ' style="stroke:none"'; // <--- 只有 n!=1 时才写 font-size
```

- **在 Preview 界面（Scale 0.6）**：
  `n` 不等于 1，SVG 元素带有 `style="font-size: 60%"`。即使父容器 CSS 没生效，浏览器也会根据这个内联样式计算出一个相对大小，虽然可能不完美，但肉眼看着还凑合。

- **在 PrintPreview 界面（Scale 1.0）**：
  我们设置了 `scale: 1.0`。AlphaTab 计算出 `n = 1`，于是触发了上述优化，生成的 SVG 元素变成：
  ```html
  <text style="stroke:none">...</text>
  <!-- 没有 font-size！ -->
  ```
  此时，这个元素的大小完全依赖于**CSS 类**（`.at-surface.at1 .at`）提供的 `34px`。

### 3. 样式选择器不匹配（Scope Mismatch）

AlphaTab 为了支持页面上存在多个实例，会给每个实例生成唯一的后缀（ID）：

- 主界面实例：`.at-surface.at` (ID为空)
- 打印界面实例：`.at-surface.at1` (ID为1)

AlphaTab 自动注入的 CSS 规则是非常具体的：

```css
/* 只有同时拥有 at-surface 和 at1 类的元素下的 .at 才有 34px */
.at-surface.at1 .at {
  font-size: 34px;
}
```

然而，我们在 `PrintPreview.tsx` 中手动构建容器或进行分页时，代码大致是这样的：

```jsx
// 我们只写了 at-surface
<div className="at-surface"> ... </div>
```

我们**丢失了实例后缀类名**（例如 `at1`）。

**结果：**

1.  SVG 元素没有内联 `font-size`（因为 Scale 1.0 优化）。
2.  SVG 父容器不匹配 `.at-surface.at1` 选择器。
3.  **浏览器回退机制**：音乐符号的字体大小回退到了浏览器的默认值（通常是 `16px`）。
4.  **视觉效果**：`16px` 只有 `34px` 的一半不到，所以音符头看起来非常小，和线条（线条是 SVG 路径，不受字体影响）完全对不上。

### 4. 为什么最终修复奏效？

我们在 CSS 中手动添加了这条规则：

```css
/* 暴力覆盖：所有 .at-surface 下的 .at 元素，强制使用 34px */
.at-surface .at {
  font-size: 34px !important;
}
```

这直接绕过了 AlphaTab 复杂的实例后缀匹配逻辑。无论容器是 `.at-surface` 还是 `.at-surface.at1`，只要它是 AlphaTab 的表面层，里面的音乐符号就会被强制设为 `34px` 的基准大小。

配合 Scale 1.0，这正是正确显示所需要的尺寸。

## Problem Description

During the implementation of the Print Preview feature, a critical rendering verify issue was observed:

- In the **Editor Preview** (scaled at ~0.6), music symbols (clefs, noteheads, accidentals) rendered correctly.
- In the **Print Preview** (scaled at 1.0 for PDF output), these same symbols rendered excessively small (tiny), appearing as barely visible dots or browser-default text size, while the stave lines and layout remained correct.

## Investigation

### 1. Visual Comparison & SVG Analysis

We compared the SVG output generated by alphaTab for both contexts:

- **Editor Preview (Scale < 1.0):**
  The generated SVG `<text>` elements included explicit inline styles:

  ```html
  <text class="at" style="font-family: 'Bravura'; font-size: 20.4px;">...</text>
  ```

  _(Note: 20.4px is approx 34px _ 0.6)\*

- **Print Preview (Scale = 1.0):**
  The generated SVG `<text>` elements **lacked** the `font-size` style:
  ```html
  <text class="at" style="font-family: 'Bravura';">...</text>
  ```

### 2. Source Code Analysis (alphaTab)

We investigated the `alphaTab.js` (specifically `fillMusicFontSymbolText` rendering logic) and discovered an optimization behavior:

1.  **Metric Calculation**: alphaTab uses an internal constant `Fc.MusicFontSize = 34` (34px) as the base size for music font symbols.
2.  **Rendering Logic**:
    - If the render scale is **not 1.0**, alphaTab calculates the size (`34 * scale`) and applies it as an inline style.
    - If the render scale **is 1.0**, alphaTab **omits the inline style**, assuming a CSS rule will handle it.
3.  **CSS Generation**:
    alphaTab generates a style tag dynamically targeting a specific instance ID:
    ```css
    .at-surface.at123 .at {
      font-size: 34px;
    }
    ```

### 3. Root Cause Implementation Mismatch

The mismatch occurred because of how we were mounting the Print Preview:

- We manually created a container `<div class="at-surface">`.
- However, we did not (and easily could not) attach the dynamic, internal instance ID class (e.g., `.at123`) that alphaTab generated for that session's stylesheet.
- Consequently, the SVG elements inside our print container matched `.at-surface` but failed to match `.at-surface.at123`.
- Without the inline style (because scale was 1.0) and without the matching CSS rule, the browser fell back to the default font size (usually 10px-16px), making the symbols appear tiny compared to the 34px expectation.

## Solution

The fix involved explicitly injecting the missing CSS rules into the Print Preview context and the Print Window context, forcing the correct font metrics without relying on alphaTab's dynamic instance classes.

### 1. Font Isolation

To prevent cache collisions or font loading race conditions between the main editor and the print worker, we ensured the print instance loads the font with a unique timestamp:

```typescript
// PrintPreview.tsx
smuflFontSources: [
  {
    font: "Bravura",
    url: `assets/bravura/Bravura.svg?print=${Date.now()}`, // Cache busting
  },
];
```

### 2. CSS Injection (The Fix)

We injected a CSS rule effectively hardcoding alphaTab's internal constant (`34px`) for our print surface. We applied this in two places:

1.  The `<style>` tag inside the Print Preview modal.
2.  The `<style>` tag written to the new window during the actual printing process.

**Injected CSS:**

```css
/* Force alphaTab's default music font size constant (34px) 
   which is omitted from inline styles when scale is 1.0 */
.at-surface .at,
.at-surface-svg .at {
  font-family: "Bravura", "Bravura Text", sans-serif !important;
  font-size: 34px !important;
}
```

## Outcome

The Print Preview now correctly renders music symbols at the intended size (34px), matching the visual proportions of the standard editor and producing high-quality PDF outputs.
